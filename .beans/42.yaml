id: '42'
title: Fix 60x performance regression with external command output
status: open
priority: 2
created_at: 2026-01-30T18:49:24.467645Z
updated_at: 2026-01-30T18:49:24.467645Z
description: |-
  ## Problem

  External commands that produce significant output are catastrophically slow. `seq 1 100` takes 210ms in rush vs 3.5ms in bash - a 60x slowdown.

  ## Benchmark Data

  | Command | Rush | Bash | Slowdown |
  |---------|------|------|----------|
  | seq 1 100 | 209.92ms | 3.51ms | 60x |
  | ls | 5.29ms | 3.74ms | 1.4x |

  Note: `ls` (small output) is only 1.4x slower, but `seq 1 100` (100 lines) is 60x slower. This strongly suggests the issue is in output handling, not command spawning.

  ## Likely Causes

  1. **Inefficient stdout reading** - Reading byte-by-byte instead of buffered
  2. **Excessive allocations** - Reallocating for each line/chunk
  3. **Synchronous I/O** - Blocking on each read instead of buffering
  4. **Pipe handling** - Inefficient pipe buffer management

  ## Investigation Areas

  - `src/executor/mod.rs` - How stdout is captured
  - `src/executor/pipeline.rs` - Pipeline output handling
  - Check for `read_to_string` vs buffered reading
  - Look for per-line allocations or copies

  ## Reproduction

  ```bash
  time ./target/release/rush -c 'seq 1 100 > /dev/null'
  # vs
  time bash -c 'seq 1 100 > /dev/null'
  ```

  ## Priority

  HIGH - This makes rush unusable for any command with significant output.
labels:
- bug
- perf
verify: 'cargo build --release && ls -lh target/release/rush'
