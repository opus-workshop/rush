id: '160'
title: 'FOUNDATION-005: POSIX control flow syntax'
status: open
priority: 1
created_at: 2026-01-30T18:49:25.298174Z
updated_at: 2026-01-30T18:49:25.298174Z
description: |-
  ## Problem
  POSIX control flow syntax fails - parser expects Rust-style braces instead of shell keywords.

  ## Current Behavior
  ```bash
  if true; then echo yes; fi    # Error: unexpected token
  while [ $i -lt 3 ]; do ...   # Error: unexpected token
  for x in a b c; do echo $x; done  # Error: unexpected token
  case $x in ...) ;; esac      # Error: unexpected token
  until [ $i -ge 3 ]; do ...   # Error: unexpected token
  ```

  ## Expected Behavior
  All POSIX control flow syntax works:
  - `if COND; then BODY; elif COND; then BODY; else BODY; fi`
  - `while COND; do BODY; done`
  - `until COND; do BODY; done`
  - `for VAR in WORDS; do BODY; done`
  - `case WORD in PATTERN) BODY;; esac`

  ## Implementation
  1. Parser needs to recognize `then/fi`, `do/done`, `esac` as keywords
  2. These are context-sensitive (only keywords after if/while/for/case)
  3. Handle compound conditions with `&&`, `||`
  4. Handle nested control flow

  ## Test Cases
  ```bash
  test_case "if then fi" 'if true; then echo yes; fi' 'yes'
  test_case "if else" 'if false; then echo yes; else echo no; fi' 'no'
  test_case "while loop" 'i=0; while [ $i -lt 3 ]; do echo $i; i=$((i+1)); done' $'0\n1\n2'
  test_case "for loop" 'for x in a b c; do echo $x; done' $'a\nb\nc'
  test_case "case statement" 'x=foo; case $x in foo) echo matched;; esac' 'matched'
  ```
