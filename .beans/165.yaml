id: '165'
title: PHF or Static Array for Builtins Map
status: open
priority: 1
created_at: 2026-01-30T18:49:25.344194Z
updated_at: 2026-01-30T18:49:25.344194Z
description: |-
  ## Problem
  `Builtins::new()` performs 47 `HashMap::insert()` calls with `.to_string()` heap allocations on every Executor construction. This costs ~0.5-1ms and happens on every shell invocation including `-c` mode.

  ## Evidence
  - Criterion: `executor_new` = ~11µs (internal), but `Builtins::new()` is the dominant cost within it
  - Each insert: key `.to_string()` allocation + hash computation + potential resize
  - 47 builtins × (alloc + hash + insert) = measurable overhead
  - Located in `src/builtins/mod.rs`

  ## Implementation Options

  ### Option A: PHF (Perfect Hash Function) - Preferred
  Use the `phf` crate to generate a compile-time perfect hash map:
  ```rust
  use phf::phf_map;
  static BUILTINS: phf::Map<&'static str, BuiltinFn> = phf_map! {
      "echo" => builtins::echo,
      "cd" => builtins::cd,
      // ... 45 more
  };
  ```
  - Zero runtime cost
  - O(1) lookup with no hash collisions
  - No heap allocations

  ### Option B: Static Array with Binary Search
  ```rust
  static BUILTINS: &[(&str, BuiltinFn)] = &[
      ("cd", builtins::cd),
      ("echo", builtins::echo),
      // ... sorted alphabetically
  ];
  // Use binary search for lookup
  ```
  - No external crate needed
  - O(log n) lookup
  - No heap allocations

  ### Option C: LazyLock with HashMap (simplest)
  ```rust
  static BUILTINS: LazyLock<HashMap<&'static str, BuiltinFn>> = LazyLock::new(|| {
      let mut m = HashMap::with_capacity(47);
      m.insert("echo", builtins::echo as BuiltinFn);
      // ...
      m
  });
  ```
  - Allocated once, shared across all Executor instances
  - Still has runtime init cost but only once per process

  ## Acceptance Criteria
  - [ ] Builtins map is constructed at compile time or lazily once (not per-Executor)
  - [ ] All 47 builtins remain accessible
  - [ ] `cargo test` passes
  - [ ] `executor_new` criterion benchmark shows measurable improvement
  - [ ] No regression in builtin lookup performance
labels:
- builtins
- performance
- startup
