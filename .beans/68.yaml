id: '68'
title: Reusable Executor Instances
status: open
priority: 2
created_at: 2026-01-30T18:49:24.615213Z
updated_at: 2026-01-30T18:49:24.615213Z
description: |-
  Reset executor state between commands instead of creating new instances.

  ## Priority: P1 - Important
  Good follow-up to persistent workers. Eliminates initialization overhead.

  ## Current Implementation
  - Each command creates new Executor::new_embedded()
  - Executor contains Runtime, Builtins, Corrector
  - All state allocated fresh per command
  - Overhead: ~1-2ms per request

  ## Proposed Solution
  Add reset() methods to reuse executor instances:
  - Executor::reset() - resets all subsystems
  - Runtime::reset() - clears variables, resets state
  - Keep executors in worker processes
  - Reset between commands instead of recreate

  ## Architecture
  ```rust
  impl Executor {
      pub fn reset(&mut self) -> Result<()> {
          self.runtime.reset()?;
          // Builtins and Corrector are stateless
          Ok(())
      }
  }

  impl Runtime {
      pub fn reset(&mut self) -> Result<()> {
          self.variables.clear();
          self.set_last_exit_code(0);
          self.scopes.clear();
          self.call_stack.clear();
          self.positional_params.clear();
          self.positional_stack.clear();
          self.function_depth = 0;
          // Keep history, undo_manager, job_manager
          Ok(())
      }
  }
  ```

  ## Acceptance Criteria
  - [ ] Executor::reset() method implemented
  - [ ] Runtime::reset() method implemented
  - [ ] Workers reuse executor instances
  - [ ] All state properly cleared between commands
  - [ ] No state leakage between requests
  - [ ] All existing tests pass
  - [ ] New reset tests added
  - [ ] Benchmark shows 1-2ms improvement
  - [ ] cargo test passes
  - [ ] cargo build --release succeeds

  ## Implementation Steps
  1. Add Executor::reset() in src/executor/mod.rs
  2. Add Runtime::reset() in src/runtime/mod.rs
  3. Update worker code to reuse executors
  4. Add comprehensive state reset tests
  5. Verify no state leakage
  6. Benchmark

  ## Files Modified
  - src/executor/mod.rs (~50 LOC)
  - src/runtime/mod.rs (~70 LOC)
  - src/daemon/worker_pool.rs (~20 LOC)

  ## Challenges
  - Identifying all state to clear
  - Deciding what to keep (history, jobs?)
  - Testing for state leakage
  - Edge cases (partial execution, errors)

  ## Testing
  - Reset clears all relevant state
  - No leakage between commands
  - Variables don't persist
  - Exit codes reset properly
  - Error conditions

  ## Estimated Effort
  2-3 hours

  ## Expected Speedup
  1-2ms reduction in daemon overhead

  ## Dependencies
  Should be implemented after rush-daemon-perf.2 (persistent workers)
labels:
- daemon
- optimization
- performance
