id: 1.5.3
title: Fallback when Pi daemon unavailable
slug: fallback-when-pi-daemon-unavailable
status: closed
priority: 1
created_at: 2026-02-03T09:07:12.460030Z
updated_at: 2026-02-03T09:11:44.920706Z
description: "## What to implement\n\nHandle the case when Pi daemon is not running gracefully.\n\n### Functions to modify\n\n1. **`execute_pipe_ask()` error handling** - Wrap Pi client connection in proper error handling:\n   - Catch `PiClientError::NotRunning`\n   - Print helpful message to stderr\n   - Return non-zero exit code\n\n## Files\n\n- `src/executor/mod.rs` (modify)\n\n## Context\n\n### PiClientError variants (from src/daemon/pi_client.rs)\n```rust\npub enum PiClientError {\n    /// Pi daemon is not running (no socket found)\n    #[error(\"Pi daemon not running: no socket found at any of the expected paths\")]\n    NotRunning,\n\n    /// Socket exists but connection failed\n    #[error(\"Failed to connect to Pi daemon at {path}: {source}\")]\n    ConnectionFailed { path: PathBuf, source: std::io::Error },\n\n    /// Protocol error\n    #[error(\"Protocol error: {0}\")]\n    ProtocolError(String),\n\n    /// I/O error\n    #[error(\"I/O error: {0}\")]\n    IoError(#[from] std::io::Error),\n}\n```\n\n### Expected error handling pattern\n```rust\nfn execute_pipe_ask(&mut self, pipe_ask: &PipeAsk) -> Result<ExecutionResult> {\n    // ... execute command and capture output ...\n    \n    // Connect to Pi\n    let mut client = match PiClient::connect() {\n        Ok(c) => c,\n        Err(PiClientError::NotRunning) => {\n            eprintln!(\"Pi daemon not running. Start with: pi daemon start\");\n            return Ok(ExecutionResult {\n                output: Output::Text(String::new()),\n                stderr: \"Pi daemon not running\".to_string(),\n                exit_code: 1,\n                error: None,\n            });\n        }\n        Err(e) => {\n            eprintln!(\"Failed to connect to Pi: {}\", e);\n            return Ok(ExecutionResult {\n                output: Output::Text(String::new()),\n                stderr: format!(\"Pi connection error: {}\", e),\n                exit_code: 1,\n                error: None,\n            });\n        }\n    };\n    \n    // ... rest of implementation ...\n}\n```\n\n### Message to display\n```\nPi daemon not running. Start with: pi daemon start\n```\n\n## Acceptance\n\n- [ ] `PiClientError::NotRunning` is caught and handled\n- [ ] Helpful error message printed to stderr\n- [ ] Exit code is non-zero (1) when Pi unavailable\n- [ ] Other `PiClientError` variants also handled gracefully\n- [ ] `cargo check` passes\n\n## Produces\n- executor_pipe_ask_fallback\n\n\n## Requires\n- executor_pipe_ask\n"
closed_at: 2026-02-03T09:11:44.920706Z
close_reason: |-
  Implemented Pi daemon fallback handling in execute_pipe_ask():
  - PiClientError::NotRunning shows helpful message "Pi daemon not running. Start with: pi daemon start"
  - PiClientError::ConnectionFailed shows path and error details
  - Other errors (IoError, ProtocolError) also handled gracefully
  - All error cases return exit code 1 with descriptive stderr
  - Added full Pi query execution flow with streaming response handling
parent: '1.5'
verify: grep -q "not running\|NotRunning\|Pi daemon" src/executor/mod.rs && cargo check 2>&1 | grep -v "^warning"
claimed_at: 2026-02-03T09:09:39.931722Z
is_archived: true
